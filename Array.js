// Higher-order - functions

//Функции от по-висок ред в JavaScript – обяснени с практически примери

// Какво е функция от по-висок ред?

// Функция от по-висок ред е функция, която приема една или повече функции като аргументи или връща функция като резултат.

// Има няколко различни типа функции от по-висок порядък като картографиране и редуциране. Ще ги обсъдим по-късно в този урок. Но преди това нека първо се потопим дълбоко в това какво представляват функциите от по-висок ред.

// Callback function, passed as a parameter in the higher order function
function callbackFunction() {
  console.log("I am  a callback function");
}

// higher order function
function higherOrderFunction(func) {
  console.log("I am higher order function");
  func();
}
higherOrderFunction(callbackFunction);
// В горния код higherOrderFunction()е HOF, защото му предаваме функция за обратно извикване като параметър.

// Горният пример е доста прост, нали? Така че нека го разширим допълнително и да видим как можете да използвате HOF, за да напишете по-сбит и модулен код.

// Как работят функциите от по-висок ред
// И така, да предположим, че искам да напишете функция, която изчислява площта и диаметъра на кръг. Като начинаещ, първото решение, което ни хрумва, е да напишем всяка отделна функция за изчисляване на площ или диаметър.

const radius = [1, 2, 3];

// function to calculate area of the circle
const calculateArea = function (radius) {
  const output = [];
  for (let i = 0; i < radius.length; i++) {
    output.push(Math.PI * radius[i] * radius[i]);
  }
  return output;
};

// function to calculate diameter of the circle
const calculateDiameter = function (radius) {
  const output = [];
  for (let i = 0; i < radius.length; i++) {
    output.push(2 * radius[i]);
  }
  return output;
};
console.log(calculateArea(radius));
console.log(calculateDiameter(radius));
// Но забелязали ли сте проблема с горния код? Не пишем ли почти една и съща функция отново и отново с малко по-различна логика? Освен това функциите, които сме написали, не могат да се използват повторно, нали?

// И така, нека да видим как можем да напишем същия код с помощта на HOF:

const radius1 = [1, 2, 3];

// logic to clculate area
const area = function (radius1) {
  return Math.PI * radius1 * radius1;
};

// logic to calculate diameter
const diameter = function (radius) {
  return 2 * radius;
};

// a reusable function to calculate area, diameter, etc
const calculate = function (radius, logic) {
  const output = [];
  for (let i = 0; i < radius.length; i++) {
    output.push(logic(radius[i]));
  }
  return output;
};

console.log(calculate(radius, area));
console.log(calculate(radius, diameter));

// Сега, както можете да видите в горния код, ние сме написали само една функция calculate()за изчисляване на площта и диаметъра на кръга. Трябва само да напишем логиката и да я предадем calculate()и функцията ще свърши работата.

// Кодът, който сме написали с помощта на HOF, е кратък и модулен. Всяка функция върши своята работа и ние не повтаряме нищо тук.

// Да предположим, че в бъдеще искаме да напишем програма за изчисляване на обиколката на кръга. Можем просто да напишем логиката за изчисляване на обиколката и да я предадем на calculate()функцията.
const circumeference = function (radius) {
  return 2 * Math.PI * radius;
};
console.log(calculate(radius, circumeference));

// Как да използвате функции от по-висок ред
// Можете да използвате функции от по-висок ред по различни начини.

// Когато работите с масиви, можете да използвате функциите map(), reduce(), filter()и sort() за манипулиране и трансформиране на данни в масив.

// Когато работите с обекти, можете да използвате Object.entries()функцията за създаване на нов масив от обект.

// Когато работите с функции, можете да използвате compose() функцията за създаване на сложни функции от по-прости.

// Как да използвате някои важни функции от по-висок ред

// Има различни вградени HOF, като някои от най-често срещаните са map(), filter() и reduce(). Така че нека разберем всеки един от тях в детайли.

// Как се използва map()в JavaScript
// Функцията map()приема масив от стойности и прилага трансформация към всяка стойност в масива. Той не променя оригиналния масив. Често се използва за трансформиране на масив от данни в нов масив с различна структура.

// Нека разберем с помощта на примери.

// Пример 1 : Да предположим, че искаме да добавим 10 към всеки елемент в масив. Можем да използваме map()метода, за да картографираме всеки елемент в масива, за да добавим 10 към него.
const arr = [1, 2, 3, 4, 5];
const output = arr.map((num) => (num += 10));
console.log(arr); // [1, 2, 3, 4, 5]
console.log(output); // [11, 12, 13, 14, 15]

// В горния пример arrе масив с пет елемента: 1, 2, 3, 4 и 5. mapе метод, който използваме, за да приложим функция към всеки елемент в масив и връща нов масив с модифицираните елементи .

// Функцията за обратно извикване, която се предава, mapизползва синтаксиса на функцията стрелка и приема един аргумент num. Тази функция добавя 10 към num(всеки елемент в масива) и връща резултата.

// Пример 2 : Тук имаме масив от потребители. Да предположим, че искаме само тяхното име и фамилия. Можем просто да използваме map()метода, за да го извлечем от usersмасива.
const users = [
  { firstName: "John", lastName: "Doe", age: 25 },
  { firstName: "Jane", lastName: "Doe", age: 30 },
  { firstName: "Jack", lastName: "Doe", age: 35 },
  { firstName: "Jill", lastName: "Doe", age: 40 },
  { firstName: "Joe", lastName: "Doe", age: 45 },
];

const result = users.map((user) => user.firstName + " " + user.lastName);
console.log(result); // ['John Doe', 'Jane Doe', 'Jack Doe', 'Jill Doe', 'Joe Doe']

// В горния код usersе масив от обекти, представляващи потребители. Всеки обект има три свойства: firstName, lastNameи age.

// Ние картографираме всеки потребител, използвайки map()метода за извличане на свойствата firstNameи lastName.

// Функцията за обратно извикване приема един аргумент user, който представлява елемент в usersмасива (обект).

// Функцията обединява свойствата firstNameи lastNameна user обекта и връща резултата.

// Как да използвате filter() в JavaScript
// Функцията filter() взема масив и връща нов масив само със стойностите, които отговарят на определени критерии. Той също така не променя оригиналния масив. Често се използва за избор на подмножество от данни от масив въз основа на определени критерии.

// Пример 1 : Можете да използвате filter(), за да върнете само нечетните числа от масив от числа.
const arr1 = [1, 2, 3, 4, 5];
const output1 = arr1.filter((num) => num % 2); // filter out odd numbers
console.log(arr1); // [1, 2, 3, 4, 5]
console.log(output1); // [1, 3, 5]

// В горния код arrе масив с пет елемента: 1, 2, 3, 4 и 5. filterе метод, който се използва за създаване на нов масив с елементи, които преминават тест, зададен в предоставена функция за обратно извикване.

// Тази функция за обратно извикване проверява дали numе нечетно, като проверява дали не се дели на 2 ( num % 2). Ако numне се дели на 2, функцията връща true, в противен случай връща false.

// Когато filter се извика arr, тя прилага тази функция към всеки елемент в масива, създавайки нов масив само с елементите, които са върнали true или преминали посоченото условие, когато са предадени на функцията. Оригиналът arr остава непроменен и връща резултата.

// Пример 2 : Можете да използвате filter(), за да върнете само потребителите на възраст над 30 години в масив.
const users1 = [
  { firstName: "John", lastName: "Doe", age: 25 },
  { firstName: "Jane", lastName: "Doe", age: 30 },
  { firstName: "Jack", lastName: "Doe", age: 35 },
  { firstName: "Jill", lastName: "Doe", age: 40 },
  { firstName: "Joe", lastName: "Doe", age: 45 },
];

// Find the users with age greater than 30
const output2 = users1.filter(({ age }) => age > 30);
console.log(output2); // [{firstName: 'Jack', lastName: 'Doe', age: 35}, {firstName: 'Jill', lastName: 'Doe', age: 40}, {firstName: 'Joe', lastName: 'Doe', age: 45}]

// В горния код usersе масив от обекти, представляващи потребители. Всеки обект има три свойства: firstName, lastNameи age.

// filter се извиква в users масива и прилага функция за обратно извикване към всеки елемент в масива.

// Функцията приема един аргумент, обект, деструктуриран до едно свойство age. Тази функция проверява дали age е по-голямо от 30. Ако е, функцията връща true, в противен случай връща false.

// Когато filter се извика users, тя прилага тази функция към всеки елемент в масива, създавайки нов масив само с елементите, върнати true при предаване на функцията, и връща резултата. Оригиналният users масив остава непроменен.

// Как се използва reduce()в JavaScript
// Методът reduce()е някак поразителен. Ако сте срещали reduce()метод преди и не сте го разбрали в началото, това е напълно добре.

// Но не се притеснявайте – тук ще го научим чрез доста примери и ще се опитам да ви накарам да разберете този метод.

// Сега едно съмнение, което може да ви хрумне, е защо използваме reduce() метода. Тъй като вече има много методи, как можем да решим кой да използваме и кога?

// В случая с reduce() метода трябва да го използвате, когато искате да извършите някаква операция върху елементите на масив и да върнете една стойност като резултат. „Единичната стойност“ се отнася до натрупания резултат от многократно прилагане на функция към елементите на последователност.

// Например, можете да използвате, reduce() за да сумирате всички елементи в масив, да намерите максималната или минималната стойност, да обедините множество обекти в един обект или да групирате различни елементи в масив.

// Сега нека разберем всичко това с помощта на примери.

// Пример 1 : Използване reduce() за сумиране на всички елементи в масив:

const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((total, currentValue) => {
  return total + currentValue;
}, 0);
console.log(sum); // 15

// В този пример reduce() методът се извиква в numbers масива и му се предава функция за обратно извикване, която приема два аргумента: total и currentValue.

// Аргументът total е натрупването на стойностите, които са били върнати от функцията досега, а currentValue е текущият елемент, който се обработва в масива.

// Методът reduce() също приема начална стойност като втори аргумент, в този случай 0, който се използва като начална стойност на total за първата итерация.

// При всяка итерация функцията добавя текущата стойност към общата сума и връща новата стойност на общата сума.

// След това методът reduce() използва върнатата стойност като за total следващата итерация, докато обработи всички елементи в масива.

// Накрая връща крайната стойност на общата сума, която е сумата от всички елементи в масива.

// Пример 2 : Използване reduce() за намиране на максималната стойност в масив:
let numbers1 = [5, 20, 100, 60, 1];
const maxValue = numbers1.reduce((max, curr) => {
  if (curr > max) max = curr;
  return max;
});
console.log(maxValue); // 100

// В този пример отново имаме два аргумента max и curr във функцията за обратно извикване. Забележете, че този път не сме предали втория параметър в reduce() метода. Така че стойността по подразбиране ще бъде първият елемент в масива.

// Функцията за обратно извикване първо проверява дали текущият елемент curr е по-голям от текущата максимална стойност max. Ако е така, той актуализира стойността на max като текущия елемент. Ако не е, max не се актуализира. Накрая функцията връща стойността на max.

// В този случай reduce() методът ще започне с настройка max на 5 и curr на 20. След това ще провери дали 20 е по-голямо от 5, което е, така че се актуализира max до 20.

// След това ще се зададе curr на 100 и ще провери дали 100 е по-голямо от 20, което е, така че се актуализира max до 100.

// Той ще продължи този процес, докато обработи всички елементи в масива. Крайната стойност на max ще бъде максималната стойност в масива, която в този случай е 100.

// Пример 3 : Използване reduce() за обединяване на различни обекти в един обект:
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const obj3 = { e: 5, f: 6 };
const mergedObj = [obj1, obj2, obj3].reduce((acc, curr) => {
  return { ...acc, ...curr };
}, {});
console.log(mergedObj); // { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 }

// В този пример имаме два аргумента acc и curr във функцията за обратно извикване. Представлява accтекущия обединен обект, който е създаден досега, докато curr представлява текущия обект, който се обработва в масива.

// Функцията използва оператора за разпространение ( ...), за да създаде нов обект, който комбинира свойствата на текущия обединен обект acc и текущия обект curr. След това връща този нов обект.

// В този случай reduce() методът ще започне с настройка acc на празен обект (което е стойността, предадена като втори аргумент на reduce()). След това ще се зададе curr на obj1 и ще се създаде нов обект, който комбинира свойствата на празния обект и obj1. След това ще се зададе curr и obj2 ще създаде нов обект, който комбинира свойствата на предишния обединен обект и obj2. Той ще продължи този процес, докато обработи всички обекти в масива.

// Крайната стойност на acc ще бъде обединеният обект, който ще съдържа всички свойства на оригиналните обекти.

// Пример 4 : Използване reduce() за групиране на обекти в масив. Например групиране на продукти в пазарска количка според името на тяхната марка.
const shoppingCart = [
  { name: "Apple", price: 1.99, quantity: 3 },
  { name: "Apple", price: 1.99, quantity: 3 },
  { name: "Xiomi", price: 2.99, quantity: 2 },
  { name: "Samsung", price: 3.99, quantity: 1 },
  { name: "Tesla", price: 3.99, quantity: 1 },
  { name: "Tesla", price: 4.99, quantity: 4 },
  { name: "Nokia", price: 4.99, quantity: 4 },
];

const products1 = shoppingCart.reduce((productGroup, product) => {
  const name = product1.name;
  if (productGroup[name] == null) {
    productGroup[name] = [];
  }
  productGroup[name].push(product1);

  return productGroup;
}, {});

console.log(products1);

// OUTPUT
// {
//   Apple: [
//     { name: 'Apple', price: 1.99, quantity: 3 },
//     { name: 'Apple', price: 1.99, quantity: 3 }
//   ],
//   Xiomi: [ { name: 'Xiomi', price: 2.99, quantity: 2 } ],
//   Samsung: [ { name: 'Samsung', price: 3.99, quantity: 1 } ],
//   Tesla: [
//     { name: 'Tesla', price: 3.99, quantity: 1 },
//     { name: 'Tesla', price: 4.99, quantity: 4 }
//   ],
//   Nokia: [ { name: 'Nokia', price: 4.99, quantity: 4 } ]
// }

// В този пример имаме shoppingCart масив, представляващ различни продукти и два аргумента productGroupи product във функцията за обратно извикване.

// Аргументът productGroup представлява текущата група от продукти, които са намерени досега, докато product аргументът представлява текущия продукт, който се обработва в масива.

// Функцията първо получава името на текущия продукт с помощта на product.name. След това проверява дали вече има група за това име на продукт в productGroup обекта, използвайки if оператора. Ако няма, създава нова група, като инициализира productGroup [name] свойството в празен масив.

// И накрая, функцията избутва текущия продукт в групата с помощта на push() метода и връща актуализирания productGroup обект.

// След като reduce() методът обработи всички елементи в shoppingCart масива, полученият productGroup обект ще съдържа ключове за всяко име на продукт и стойности, които са масиви от продукти с това име.

// Предимства на функциите от по-висок ред
// Използването на функции от по-висок ред има някои важни предимства за уеб разработчиците.

// Първо, функциите от по-висок ред могат да помогнат за подобряване на четливостта на вашия код, като го направят по-сбит и лесен за разбиране. Това може да помогне за ускоряване на процеса на разработка и да улесни отстраняването на грешки в кода.

// Второ, функциите от по-висок ред могат да ви помогнат да организирате кода си на по-малки части, което го прави по-лесен за поддръжка и разширяване.

// Използвайки функции от по-висок порядък, уеб разработчиците могат да работят по-интелигентно, като организират своя код на по-малки части и го направят по-четлив и по-лесен за отстраняване на грешки.

// Сега, когато се опитате да използвате методите map(), filter() и reduce() и се объркате, просто помнете следното:

// Използвайте (map(),)  когато искате да трансформирате масив

// Използвайте filter()  филтър, за да изберете подмножество от данни от масив и

// Използвайте reduce() намаляване, когато искате да върнете една стойност като резултат.

// 10 задачи с Higher-Order Functions (HOF)

// Задача 1: Умножение на числа
// Имате масив от числа: [2, 4, 6, 8]. Умножете всяко число по 3 и върнете новия масив.

// Задача 2: Избиране на числа
// Имате масив от числа: [5, 12, 18, 23, 30, 42]. Изберете само числата, които са по-големи от 20.

// Задача 3: Обща сума
// Имате масив от числа: [10, 20, 30, 40, 50]. Намерете сумата на всички числа.

// Задача 4: Думи с определена дължина
// Имате масив от думи: ["apple", "banana", "cherry", "date"]. Изберете само тези думи, които имат повече от 5 букви.

// Задача 5: Повишаване на заплатите
// Имате масив от обекти с имена и заплати на служители:
const employees = [
  { name: "Ivan", salary: 1500 },
  { name: "Maria", salary: 2000 },
  { name: "Peter", salary: 2500 },
];
// Увеличете заплатите на всички служители с 20%.

// Задача 6: Средна оценка
// Имате масив от оценки: [3, 4, 5, 6, 5]. Намерете средната оценка.

// Задача 7: Подреждане на продукти
// Имате масив от продукти с име и цена:
const products = [
  { name: "Laptop", price: 1200 },
  { name: "Phone", price: 800 },
  { name: "Tablet", price: 600 },
];
// Изберете само продуктите, които струват над 700, и върнете нов масив с техните имена.

// Задача 8: Умножение на нечетни числа
// Имате масив от числа: [1, 2, 3, 4, 5, 6]. Умножете само нечетните числа по 2 и върнете новия масив.

// Задача 9: Думи с главни букви
// Имате масив от думи: ["hello", "world", "javascript", "functions"]. Преобразувайте всяка дума, така че първата буква да бъде главна.

// Задача 10: Общи продажби
// Имате масив от обекти с продажби:
const sales = [
  { product: "A", amount: 100 },
  { product: "B", amount: 200 },
  { product: "C", amount: 150 },
];
// Намерете общата сума на продажбите.

// Използвайте map – за трансформация.

// Използвайте filter – за селекция.

// Използвайте reduce – за изчисление на една стойност.
